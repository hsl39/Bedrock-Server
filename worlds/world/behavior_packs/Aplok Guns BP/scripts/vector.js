/**
 * "chatgpt make a complete vector3 ts class to me pls" frfrfrfr
 */

export class Vector{static fromSpherical(t,i,s){return new Vector(t*Math.sin(i)*Math.cos(s),t*Math.sin(i)*Math.sin(s),t*Math.cos(i))}getMagnitude(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}setMagnitude(t){let i=this.getDirection();this.x=Math.cos(i.phi)*Math.sin(i.theta)*t,this.y=Math.sin(i.phi)*Math.sin(i.theta)*t,this.z=Math.cos(i.theta)*t}normalize(){let t=this.getMagnitude();this.x/=t,this.y/=t,this.z/=t}add(t){return new Vector(this.x+t.x,this.y+t.y,this.z+t.z)}addTo(t){this.x+=t.x,this.y+=t.y,this.z+=t.z}subtract(t){return new Vector(this.x-t.x,this.y-t.y,this.z-t.z)}subtractFrom(t){this.x-=t.x,this.y-=t.y,this.z-=t.z}multiply(t){return new Vector(this.x*t,this.y*t,this.z*t)}multiplyBy(t){this.x*=t,this.y*=t,this.z*=t}divide(t){return new Vector(this.x/t,this.y/t,this.z/t)}divideBy(t){this.x/=t,this.y/=t,this.z/=t}dotProduct(t){return this.x*t.x+this.y*t.y+this.z*t.z}crossProduct(t){return new Vector(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x)}getDirection(){return{theta:Math.acos(this.z/this.getMagnitude()),phi:Math.atan2(this.y,this.x)}}setDirection(t,i){let s=this.getMagnitude();this.x=Math.sin(t)*Math.cos(i)*s,this.y=Math.sin(t)*Math.sin(i)*s,this.z=Math.cos(t)*s}copy(){return new Vector(this.x,this.y,this.z)}toString(t){if(!t)return`Vector <${this.x}, ${this.y}, ${this.z}>`;{let i=this.getDirection();return`Vector (s) <${this.getMagnitude()}, ${i.theta}, ${i.phi}>`}}toArray(){let t=this.getDirection();return[this.x,this.y,this.z,t.theta,t.phi,this.getMagnitude()]}toObject(){let t=this.getDirection();return{x:this.x,y:this.y,z:this.z,theta:t.theta,phi:t.phi,radius:this.getMagnitude()}}constructor(t,i,s){this.x=t,this.y=i,this.z=s}}
